-- Baseline multi-tenant auth schema, RLS, and JWT claims function
-- Idempotent: uses CREATE IF NOT EXISTS and guards

-- SCHEMA --------------------------------------------------------------------
create table if not exists public.orgs (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  slug text unique not null,
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- profiles: 1:1 with auth.users
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text not null,
  full_name text,
  mfa_enabled boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- user_orgs: M:N membership with role at membership level
create table if not exists public.user_orgs (
  user_id uuid not null references auth.users(id) on delete cascade,
  org_id uuid not null references public.orgs(id) on delete cascade,
  role text not null check (role in ('org_admin','member')),
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  unique(user_id, org_id)
);

-- roles: tenant-scoped RBAC roles (custom)
create table if not exists public.roles (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null references public.orgs(id) on delete cascade,
  name text not null,
  slug text not null,
  description text,
  created_at timestamptz not null default now(),
  unique(org_id, slug)
);

-- permissions catalog (global)
create table if not exists public.permissions (
  id uuid primary key default gen_random_uuid(),
  key text unique not null,
  description text
);

-- role_assignments: role -> permission mapping (tenant scoped roles, global perms)
create table if not exists public.role_assignments (
  role_id uuid not null references public.roles(id) on delete cascade,
  permission_id uuid not null references public.permissions(id) on delete cascade,
  created_at timestamptz not null default now(),
  unique(role_id, permission_id)
);

-- invitations
create table if not exists public.invitations (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null references public.orgs(id) on delete cascade,
  email text not null,
  role text not null check (role in ('org_admin','member')),
  token text not null unique,
  expires_at timestamptz not null,
  accepted_at timestamptz,
  created_at timestamptz not null default now()
);

-- audit logs (append-only)
create table if not exists public.audit_logs (
  id bigint generated by default as identity primary key,
  org_id uuid,
  actor_id uuid,
  action text not null,
  subject text,
  object_id uuid,
  metadata jsonb,
  ip text,
  user_agent text,
  occurred_at timestamptz not null default now()
);

-- Helper: active org claim extraction
create or replace function public.get_jwt_claim(claim text)
returns text language sql stable as $$
  select nullif(current_setting('request.jwt.claims', true)::jsonb ->> claim, '')
$$;

-- Inject active org and role info into JWT via Postgres function
-- Call this from Supabase JWT hooks configuration (jwt_secret claim transform)
create or replace function public.jwt_enrich(session_user_id uuid)
returns jsonb language plpgsql security definer as $$
declare
  active_org uuid;
  membership_role text;
  claims jsonb := '{}'::jsonb;
begin
  -- pick first active membership as default active org if none explicitly set
  select uo.org_id, uo.role into active_org, membership_role
  from public.user_orgs uo
  where uo.user_id = session_user_id and uo.is_active = true
  order by created_at asc
  limit 1;

  if active_org is not null then
    claims := jsonb_build_object('org_id', active_org::text);
  end if;
  if membership_role is not null then
    claims := claims || jsonb_build_object('org_role', membership_role);
  end if;
  return claims;
end;
$$;

-- RLS -----------------------------------------------------------------------
alter table public.profiles enable row level security;
alter table public.user_orgs enable row level security;
alter table public.roles enable row level security;
alter table public.role_assignments enable row level security;
alter table public.invitations enable row level security;
alter table public.audit_logs enable row level security;

-- policy helpers
create or replace function public.current_org_id()
returns uuid language sql stable as $$
  select nullif(public.get_jwt_claim('org_id'), '')::uuid
$$;

create or replace function public.is_org_admin(user_id uuid, org_id uuid)
returns boolean language sql stable as $$
  select exists(
    select 1 from public.user_orgs uo
    where uo.user_id = user_id and uo.org_id = org_id and uo.role = 'org_admin' and uo.is_active
  )
$$;

-- profiles: user can read/update own profile
drop policy if exists profiles_select_self on public.profiles;
create policy profiles_select_self on public.profiles
for select using (auth.uid() = id);

drop policy if exists profiles_update_self on public.profiles;
create policy profiles_update_self on public.profiles
for update using (auth.uid() = id);

-- user_orgs scoped by active org claim
drop policy if exists user_orgs_select_org on public.user_orgs;
create policy user_orgs_select_org on public.user_orgs
for select using (org_id = public.current_org_id());

-- only admins can insert/delete memberships within their active org
drop policy if exists user_orgs_modify_admin on public.user_orgs;
create policy user_orgs_modify_admin on public.user_orgs
for all using (
  public.is_org_admin(auth.uid(), public.current_org_id()) and org_id = public.current_org_id()
);

-- roles
drop policy if exists roles_select_org on public.roles;
create policy roles_select_org on public.roles
for select using (org_id = public.current_org_id());

drop policy if exists roles_modify_admin on public.roles;
create policy roles_modify_admin on public.roles
for all using (
  public.is_org_admin(auth.uid(), public.current_org_id()) and org_id = public.current_org_id()
);

-- role_assignments follow roles via join in service; keep same policy
drop policy if exists role_assignments_select_org on public.role_assignments;
create policy role_assignments_select_org on public.role_assignments
for select using (
  exists (select 1 from public.roles r where r.id = role_id and r.org_id = public.current_org_id())
);

drop policy if exists role_assignments_modify_admin on public.role_assignments;
create policy role_assignments_modify_admin on public.role_assignments
for all using (
  exists (select 1 from public.roles r where r.id = role_id and public.is_org_admin(auth.uid(), r.org_id) and r.org_id = public.current_org_id())
);

-- invitations visible/managed only within org by admin
drop policy if exists invitations_select_org on public.invitations;
create policy invitations_select_org on public.invitations
for select using (org_id = public.current_org_id());

drop policy if exists invitations_modify_admin on public.invitations;
create policy invitations_modify_admin on public.invitations
for all using (
  public.is_org_admin(auth.uid(), public.current_org_id()) and org_id = public.current_org_id()
);

-- audit_logs: read within org, insert allowed for service users; append-only
drop policy if exists audit_logs_select_org on public.audit_logs;
create policy audit_logs_select_org on public.audit_logs
for select using (org_id is null or org_id = public.current_org_id());

drop policy if exists audit_logs_insert_any on public.audit_logs;
create policy audit_logs_insert_any on public.audit_logs
for insert with check (true);

-- SEED minimal permissions ---------------------------------------------------
insert into public.permissions(key, description)
values
  ('manage:members', 'Manage org members and roles'),
  ('view:members', 'View org members'),
  ('manage:roles', 'Manage roles'),
  ('view:roles', 'View roles')
on conflict (key) do nothing;


